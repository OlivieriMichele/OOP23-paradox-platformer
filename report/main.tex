\documentclass[a4paper,12pt]{report}

\usepackage{alltt, fancyvrb, url}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{float}
\usepackage{hyperref}

% Questo commentalo se vuoi scrivere in inglese.
\usepackage[italian]{babel}

\usepackage[italian]{cleveref}

\title{Relazione OOP\\``Paradox Platformer''}

\author{Ji Junkai, Keegan Falcao, Olivieri Michele}
\date{\today}


\begin{document}
	
	\maketitle
	
	\tableofcontents
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=\linewidth]{StartingScreen.png}
		\caption{Figura 1: Starting Screen}
	\end{figure}
	
	\chapter{Analisi}
	
	Il gioco preso in analisi è un platform game 2D chiamato \textbf{Paradox Platformer}. Il giocatore controlla un personaggio attraverso l'uso delle frecce direzionali, con l'obiettivo di raggiungere la fine della mappa, per passare al livello successivo. Tuttavia, il gioco introduce una serie di sfide controintuitive: oggetti che sembrano innocui possono rivelarsi letali, e viceversa. Ad esempio, alcuni oggetti come le monete e i \textbf{deathCoin} appaiono identici, ma uno può essere raccolto senza conseguenze mentre l'altro uccide il giocatore. Pertanto la caratteristica distintiva del gioco è che molti degli ostacoli e degli elementi della mappa si modificano in risposta a specifici trigger attivati dal giocatore, i quali possono trasformare anche le condizioni di vittoria e sconfitta. Il gioco sfida le aspettative del giocatore, richiedendo attenzione non solo agli ostacoli evidenti ma anche a quelli che cambiano dinamicamente.
	
	\section{Descrizione}
	
	Il software mira alla creazione di un platform game: \textbf{Paradox Platformer}, in cui il giocatore esplora una serie di mappe superando ostacoli e attivando meccanismi che modificano l’ambiente di gioco. Il giocatore, controllato tramite le frecce direzionali, deve muoversi con attenzione, poiché molti elementi apparentemente innocui possono trasformarsi in pericoli letali. Le monete raccolte possono contribuire al progresso o, in alcuni casi, causare la sconfitta. Gli ostacoli nel gioco possono variare la loro natura e comportamento, creando una sfida costante e spingendo il giocatore a prestare attenzione sia agli oggetti visibili che ai trigger nascosti che potrebbero attivarsi durante il percorso.
	
	\section{Modello del Dominio}
	
	\textbf{Paradox Platformer} prevede un \textbf{giocatore} che si muove all'interno di diversi \textbf{livelli}. Ogni livello è composto da una serie di \textbf{ostacoli} e \textbf{trigger}. Gli ostacoli possono essere di varia natura, come \textbf{ostacoli letali} (es. deathObstacle) o \textbf{non letali}, e possono modificare il comportamento del giocatore in modi controintuitivi. I trigger attivano degli \textbf{effetti} specifici al verificarsi di determinati eventi, come collisioni o il raggiungimento di un certo punto del livello.
	
	Le \textbf{entità principali} in gioco includono:
	
	• Il \textbf{giocatore}, che interagisce con l'ambiente di gioco tramite input da tastiera.
	
	• I \textbf{livelli}, ciascuno dei quali contiene una serie di ostacoli e trigger.
	
	• Gli \textbf{ostacoli}, che possono essere letali o non letali e possono comportarsi in modo inaspettato.
	
	• I \textbf{trigger}, associati agli ostacoli, che attivano effetti in risposta a eventi specifici.
	
	• Gli \textbf{effetti}, che determinano le conseguenze delle interazioni tra il giocatore e l'ambiente.
	
	\begin{figure}[H]
		\centering{}
		\includegraphics{img/analysis.pdf}
		\caption{Schema UML dell'analisi del problema, con rappresentate le entità principali ed i rapporti fra loro}
		\label{img:analysis}
	\end{figure}
	
	\section{Requisiti}
	
	\subsubsection{Requisiti funzionali}
	\begin{itemize}
		\item Il gioco, \textbf{Paradox Platformer}, sarà un platform 2D in cui il giocatore dovrà esplorare una serie di livelli caratterizzati da sfide controintuitive e ostacoli unici. L’obiettivo principale sarà superare ostacoli e raggiungere la porta di uscita di ogni livello per passare al successivo.
		\item Ogni livello conterrà una combinazione di ostacoli letali e non letali. Gli ostacoli letali causeranno la sconfitta immediata del giocatore, mentre quelli non letali modificheranno temporaneamente le sue abilità o l’ambiente di gioco.
		\item I trigger saranno associati a determinati ostacoli e si attiveranno quando il giocatore li colpirà o soddisferà certe condizioni. Questi trigger potranno attivare effetti come cambiamenti nell’ambiente di gioco o nella fisica del personaggio.
		\item Ogni ostacolo presenterà una meccanica che sfida le aspettative del giocatore, creando un’esperienza di gioco complessa e imprevedibile.
		\item Il gioco sarà strutturato su livelli progressivamente più difficili, con nuove meccaniche introdotte in ogni fase.
		\item Sarà presente un sistema di progressione, che permetterà ai giocatori di sbloccare livelli successivi man mano che completano quelli precedenti. Il gioco salverà automaticamente i progressi.
		\item Il sistema di fine gioco varierà a seconda delle azioni del giocatore, come la raccolta di monete per passare al livello successivo. La raccolta di un certo numero di monete potrebbe sbloccare l'accesso ai livelli successivi.
		\item Verrà implementato un sistema di punteggi che registrerà i tentativi falliti e i successi, rendendo visibili i progressi del giocatore attraverso un’interfaccia grafica.
	\end{itemize}
	
	\subsubsection{Requisiti non funzionali}
	\begin{itemize}
		\item Il gioco dovrà funzionare in modo fluido su diversi dispositivi, garantendo un framerate costante e tempi di risposta rapidi anche con livelli complessi e numerosi effetti attivi.
		\item Il sistema dovrà essere facilmente estensibile, consentendo l’aggiunta di nuovi livelli e meccaniche senza la necessità di rifattorizzare grandi porzioni di codice esistente.
		\item Il consumo di risorse del gioco dovrà essere ottimizzato, specialmente nelle piattaforme con risorse limitate, per garantire performance ottimali su un’ampia gamma di dispositivi.
		\item Il sistema dovrà essere portabile su diversi sistemi operativi, assicurando che la logica di gioco e le meccaniche funzionino correttamente su piattaforme sia desktop che mobile.
		\item Il gioco dovrà essere dotato di sicurezza nei salvataggi, garantendo che i dati del progresso del giocatore non siano corrotti o persi.
	\end{itemize}
	
	\chapter{Design}
	
	In questo capitolo vengono illustrate le strategie adottate per soddisfare i requisiti identificati durante la progettazione di Paradox Platformer. Si inizia con una visione architetturale ad alto livello per chiarire come le componenti principali del gioco, come il controller, il modello e la vista, interagiscono e si coordinano tra loro. Successivamente, si approfondiscono i principali aspetti del design, mettendo in luce come le scelte architetturali e le implementazioni specifiche contribuiscono a garantire un'applicazione modulare e scalabile, adatta a gestire le complessità del gameplay e dell'interazione utente.
	
	\section{Architettura}
	
	L'architettura di \textit{Paradox Platformer} adotta il pattern architetturale \textbf{Model-View-Controller} (MVC) per separare le responsabilità e garantire una struttura modulare e flessibile. Questo approccio facilita la gestione e l'evoluzione del sistema, evitando accoppiamenti stretti tra le componenti principali. Di seguito vengono descritti i ruoli e le interazioni dei principali componenti architetturali del progetto.
	
	\subsection{Controller}
	
	Il \textbf{Controller} è il cuore della logica di controllo del gioco e si occupa di orchestrare le interazioni tra il \textbf{Model} e la \textbf{View}. La separazione delle responsabilità all'interno del controller è fondamentale per mantenere la logica del gioco chiara e scalabile. I principali componenti del controller sono:
	
	\begin{itemize} \item \textbf{GameControllerImpl}: gestisce il ciclo di vita del gioco, la sincronizzazione tra eventi, input dell’utente e visualizzazione. Coordina anche le verifiche delle condizioni di vittoria e sconfitta tramite l'EndGameManager e le condizioni specifiche di fine gioco. \item \textbf{InputController}: si occupa della gestione degli input del giocatore, catturando gli eventi di tastiera e aggiornando lo stato del personaggio e del mondo di gioco di conseguenza. \item \textbf{EventManager}: segue il pattern Singleton e gestisce gli eventi asincroni tra le componenti del sistema, assicurando che il GameController, il Model e la View comunichino efficacemente tra loro. \item \textbf{EndGameManager}: verifica le condizioni di vittoria e sconfitta. Controlla se il giocatore ha completato il livello o subito una sconfitta e delega la gestione di ciascuno stato alle componenti appropriate. \end{itemize}
	
	\subsection{Model}
	
	Il \textbf{Model} rappresenta la logica centrale del gioco, comprendente gli elementi che costituiscono il mondo di gioco e le regole che ne determinano il comportamento. I principali componenti del modello sono:
	
	\begin{itemize} \item \textbf{Game World}: contiene la rappresentazione dell’intera mappa di gioco, compresi gli oggetti, gli ostacoli e i trigger. Gestisce il posizionamento e lo stato di ogni elemento nel livello attuale. 
		
		\item \textbf{Player}: rappresenta il personaggio controllato dal giocatore, con attributi come posizione, salute e velocità. Il movimento del giocatore viene aggiornato in base all’input ricevuto dall’InputController. 
		
		\item \textbf{Ostacoli}: include gli ostacoli letali e non letali che interagiscono con il giocatore. Gli ostacoli letali come il \textit{DeathObstacle} causano la sconfitta immediata, mentre quelli non letali possono modificare temporaneamente le abilità del giocatore o l’ambiente circostante. \item  \end{itemize}
	
	\subsection{View}
	
	La \textbf{View} si occupa della rappresentazione grafica del gioco e della visualizzazione dello stato attuale del modello. È progettata per separare la logica di rendering dalle meccaniche di gioco, garantendo un gioco reattivo e fluido. La divisione di responsabilitò della view dal modello permette la costruzione di un gioco indipendente dal modello adoperato, diffatti il gioco può funzionare anche se il framework dell'applicazione è differente (e.g Swing, JavaFX o Console). Tale funzionalità è presente in questo progetto, in quanto ogni componente della vista è sviluppata secondo due componenti comuni per tutte le viste (i nodi e gli identificatori dei tasti).
	I principali componenti della vista sono:
	
	\begin{itemize} \item \textbf{Vista del Gioco}: l’area di rendering principale, responsabile del disegno della mappa, del personaggio, degli ostacoli e degli altri elementi di gioco. Viene aggiornata in tempo reale in base alle informazioni fornite dal GameController. 
		
		\item \textbf{Gestione della Vista}: detiene lo stato dell'applicazione, funge da esecutore per qualsiasi azione compiuta dall'utente nei confronti dell'applicazione. 
		
		\item \textbf{Libertà d'uso del Framework}: permette una scelta ampia del framework che si andrà ad adottare, senza andare a compromettere lo scheletro del gioco, ossia la costruzione delle componenti grafiche di esso. In pratica sostituendo il framework la vista funziona ugualmente.
		
	\end{itemize}
	
	\subsection{Comunicazione tra i Componenti}
	
	La comunicazione tra i vari componenti del sistema è gestita principalmente dall'EventManager. Questo consente al Controller di coordinarsi con il Model e la View senza che queste siano direttamente collegate tra loro. Ad esempio, quando il giocatore raccoglie una moneta o attiva un trigger, l'EventManager notifica il GameController, che aggiorna lo stato del gioco e lo comunica alla View per il rendering.
	
	\subsection{Estendibilità e Scalabilità}
	
	L'architettura di \textit{Paradox Platformer} è progettata per garantire estensibilità e scalabilità. L’uso di factory per le condizioni di vittoria e sconfitta consente di adattare facilmente il gioco a nuovi livelli e meccaniche senza modificare la logica principale. Inoltre, il pattern Singleton per la gestione degli eventi e la struttura modulare di input, logica e visualizzazione facilitano l'aggiunta di nuove funzionalità e miglioramenti nel tempo.
	
	
	\section{Design Dettagliato}
	
	In questa sezione, esploreremo in dettaglio gli aspetti chiave del design del nostro gioco \textit{Paradox Platformer}. Cominceremo con una panoramica delle classi \texttt{ViewManager} e \texttt{GameControllerImpl}, che forniscono la struttura generale del gioco. Successivamente, ci concentreremo sui componenti specifici: \texttt{PlayerModel}, \texttt{EndGameManager} e \texttt{JumpBehavior}, approfondendo le soluzioni adottate, i vantaggi, i possibili svantaggi e i pattern di design utilizzati.
	
	\subsection{Panoramica Generale}
	
	\subsubsection{SimpleController}
	
	\texttt{ViewManager} è responsabile della gestione del ciclo di vita dell'applicazione, del passaggio tra le diverse viste e delle routine di inizializzazione. Questa classe funge da coordinatore principale, facilitando l'interazione tra le viste e i vari componenti del modello.
	
	\paragraph{Problema:} La gestione del ciclo di vita dell'applicazione e delle viste può diventare complessa man mano che il progetto cresce. È necessario garantire che le transizioni tra le diverse parti del gioco siano fluide e che tutte le risorse siano inizializzate correttamente.
	
	\paragraph{Soluzione Proposta:} \texttt{ViewManager} utilizza un design centralizzato per gestire le transizioni e l'inizializzazione della view. Implementa il pattern \textit{Singleton} per garantire che esista una sola istanza del controller durante l'intera esecuzione del gioco, assicurando coerenza e facilità di accesso ai servizi globali.
	
	\paragraph{Vantaggi e Svantaggi:} 
	Il pattern \textit{Singleton} offre il vantaggio di una gestione centralizzata delle risorse e della configurazione dell'applicazione. Tuttavia, un uso eccessivo di Singleton può portare a problemi di testabilità e di accoppiamento stretto. È importante utilizzare questo pattern con attenzione per evitare che il controller diventi un punto di accoppiamento rigido.
	
	\subsubsection{GameControllerImpl}
	
	\texttt{GameControllerImpl} gestisce il modello del gioco, la sincronizzazione della vista, le collisioni e le condizioni di vittoria/sconfitta. È il cuore della logica di gioco, responsabile della coerenza tra la logica del gioco e la sua rappresentazione visiva.
	
	\paragraph{Problema:} La gestione della logica di gioco e la sincronizzazione tra il modello e la vista possono diventare complesse. È fondamentale assicurare che il modello del gioco e la vista rimangano sincronizzati e che le condizioni di vittoria e sconfitta siano controllate correttamente.
	
	\paragraph{Soluzione Proposta:} \texttt{GameControllerImpl} adotta il pattern \textit{Observer} per gestire la sincronizzazione tra il modello e la vista. Gli oggetti che rappresentano il modello del gioco notificano le modifiche agli osservatori (come la vista) quando lo stato del gioco cambia. Inoltre, utilizza il pattern \textit{Strategy} per le condizioni di vittoria e sconfitta, permettendo di definire e verificare diverse condizioni senza modificare il codice del controller.
	
	\paragraph{Vantaggi e Svantaggi:} 
	L'uso del pattern \textit{Observer} facilita la sincronizzazione tra il modello e la vista, rendendo il sistema più modulare e facile da mantenere. Tuttavia, un numero elevato di osservatori può portare a un aumento della complessità e dei costi di gestione delle notifiche. È importante bilanciare l'uso di questo pattern con considerazioni sulla performance e sulla semplicità del design.
	
	\subsection{Olivieri MIchele}
	
	\subsubsection{PlayerModel}
	
	\paragraph{Problema:} Il modello del giocatore deve rappresentare e gestire lo stato del personaggio, comprese la posizione, la velocità e il comportamento di salto. Deve inoltre interagire con gli ostacoli e gli oggetti del livello. È fondamentale che il modello del giocatore possa comunicare efficacemente con il resto del sistema di gioco per riflettere i cambiamenti di stato e interagire con altri componenti.
	
	\paragraph{Soluzione Proposta:} \texttt{PlayerModel} incapsula lo stato e le azioni del giocatore. Utilizza il pattern \textit{Strategy} per gestire il comportamento di salto, permettendo di cambiare dinamicamente le strategie di salto in base alle esigenze del gioco. Questo approccio consente una gestione flessibile e modulare del comportamento del giocatore, facilitando l'integrazione con il resto del sistema di gioco.
	
	\paragraph{Vantaggi e Svantaggi:} 
	Il pattern \textit{Strategy} per il comportamento di salto offre grande flessibilità e facilità di estensione, permettendo di aggiungere nuovi tipi di salto senza modificare il modello del giocatore. Tuttavia, questo può aumentare la complessità del codice, richiedendo una gestione accurata delle strategie e delle loro interazioni. Inoltre, è importante garantire che il \texttt{PlayerModel} comunichi efficacemente con altri componenti come il \texttt{GameControllerImpl} per garantire una sincronizzazione accurata dello stato del gioco.
	
	\begin{figure}[H]
		\centering{}
		\includegraphics[width=\textwidth]{img/player2.png}
		\caption{Schema UML di Player}
		\label{img:player}
	\end{figure}
	
	\subsubsection{EndGameManager}
	
	\paragraph{Problema:} La gestione della fine del gioco deve determinare se il giocatore ha soddisfatto le condizioni di vittoria o di sconfitta. Questo richiede un sistema modulare che possa gestire diverse condizioni e reagire di conseguenza. Inoltre, è essenziale che il gestore delle vittorie e delle sconfitte possa comunicare efficacemente con il resto del sistema di gioco per garantire una transizione fluida tra i livelli e una corretta gestione degli stati finali.
	
	\paragraph{Soluzione Proposta:} Il \texttt{EndGameManager} utilizza un design basato sui pattern \textit{Factory} e \textit{Strategy} per gestire le condizioni di vittoria e sconfitta. La factory è responsabile della creazione delle condizioni di vittoria e sconfitta appropriate per il livello corrente, mentre le strategie concrete verificano se le condizioni sono soddisfatte. Questo approccio consente una gestione modulare e flessibile delle condizioni di fine gioco, facilitando l'aggiunta di nuove condizioni senza modificare il gestore principale.
	
	\paragraph{Vantaggi e Svantaggi:} 
	L'uso del pattern \textit{Factory} facilita l'estensione del sistema di condizioni di vittoria e sconfitta, permettendo di aggiungere nuove condizioni senza modificare il \texttt{EndGameManager}. Il pattern \textit{Strategy} consente una verifica modulare e flessibile delle condizioni. Tuttavia, la complessità del sistema aumenta con l'aggiunta di nuove condizioni, e la gestione di molteplici strategie può richiedere una maggiore attenzione. Inoltre, è cruciale garantire che il \texttt{EndGameManager} interagisca correttamente con il \texttt{GameControllerImpl} e altri componenti del sistema per una gestione fluida degli stati finali e delle transizioni tra i livelli.
	
	\begin{figure}[H]
		\centering{}
		\includegraphics[width=\textwidth]{img/endgamemanager2.png}
		\caption{Schema UML di End Game Manager}
		\label{img:endgamemanager}
	\end{figure}
	
	\subsubsection{JumpBehavior}
	
	\paragraph{Problema:} Il comportamento di salto del personaggio deve essere gestito in modo flessibile, supportando diversi stili di salto. La soluzione deve essere estensibile e facilmente modificabile per adattarsi alle esigenze del gioco.
	
	\paragraph{Soluzione Proposta:} Il comportamento di salto è implementato utilizzando il pattern \textit{Strategy}. L'interfaccia \texttt{JumpBehavior} definisce il contratto per le strategie di salto, mentre le classi concrete come \texttt{PlatformJump} e \texttt{FlappyJump} forniscono implementazioni specifiche. Questo approccio consente di cambiare dinamicamente il comportamento di salto senza modificare il codice esistente.
	
	\paragraph{Vantaggi e Svantaggi:} 
	Il pattern \textit{Strategy} per il comportamento di salto offre grande flessibilità e facilità di estensione, permettendo di aggiungere nuovi tipi di salto senza modificare il codice esistente. Tuttavia, questo può introdurre una maggiore complessità nella gestione delle diverse strategie e richiedere un'attenta progettazione per evitare la proliferazione di classi.
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=\textwidth]{img/playerjump2.png}
		\caption{Schema UML di JumpBehaviour}
		\label{img:jump}
	\end{figure}
	
	
	\subsection{Keegan Carlo Falcao}
	\subsubsection{Ostacoli}
	
	\paragraph{Problema:} Il problema affrontato dagli Ostacoli è la necessità di standardizzare i comportamenti comuni per diversi tipi di ostacoli in un gioco, consentendo al contempo che ogni ostacolo definisca il proprio comportamento specifico, come la gestione delle collisioni o gli effetti di attivazione. Senza un approccio strutturato, l'implementazione di questi comportamenti variabili tra ostacoli diversi porterebbe a codice ridondante e a una mancanza di coerenza.
	
	\paragraph{Soluzione:}La soluzione è fornita dall'uso del \textit{Template Method}. Questo pattern consente alla classe AbstractObstacle di definire uno schema per i comportamenti comuni (come l'aggiornamento dello stato, la gestione del movimento e delle dimensioni), delegando invece gli aspetti specifici, come la gestione delle collisioni, alle sue sottoclassi tramite metodi astratti come getCollisionType(). Questo approccio permette di riutilizzare il codice e garantire una gestione coerente dei comportamenti tra gli ostacoli, mantenendo allo stesso tempo la flessibilità per implementare logiche specifiche nelle singole sottoclassi.
	
	\subsubsection{Componente Grafica}
	
	\paragraph{Problema:} La maggior parte di noi avrebbe usato solo i controlli di un framework specifico e l'intera vista sarebbe ruotata attorno ad essa, rendendola prestabilita. Dunque si presentava il problema di utilizzare un componente grafico comune che adottasse diverse specifiche richieste dai diversi framework.
	
	\paragraph{Soluzione:}A fronte del problema si è scelto di usare il pattern {Adapter} che funge da intermediario tra il componente grafico comune e i diversi framework. L'Adapter traduce le richieste specifiche di ciascun framework (come il settaggio della dimensione e della posizione) in comandi compatibili con il componente grafico comune. Inoltre è stato sfruttato il pattern \textit{Template Method} per creare diversi tipi di controlli avente certe funzionalità in comune.
	
	\paragraph{Vantaggi e Svantaggi:} L'uso del pattern Adapter offre vantaggi come il riutilizzo del codice e una maggiore flessibilità, permettendo a un componente grafico comune di adattarsi a diversi framework senza riscrivere il codice. Questo approccio migliora la separazione delle responsabilità e facilita l'estensione dei comportamenti comuni grazie al pattern Template Method. Tuttavia, può aumentare la complessità del progetto e rendere il codice più difficile da mantenere. Inoltre, l'Adapter può introdurre un overhead che influisce sulle performance e richiede una buona conoscenza dei framework, complicando la gestione a lungo termine.
	
	
	\subsubsection{Modello dei Movimenti}
	
	\paragraph{Problema:} All'Utente deve essere garantita la possibiltà di poter usare differenti configurazioni di comandi per i movimenti del giocatore. Inoltre, certe configurazioni richiedono una combinazione di quelli basilari quali 'arrow keys' o 'wasd'.
	
	\paragraph{Soluzione:} \textit{Factory} risulta il pattern di composizione più ragionevole nel creare diverse confiugrazioni ciascuna avente diversi input per gestire il movimento del giocatore, mentre \textit{Decorator} è utile per creare una combinazione delle due: si crea un configurazione complessa mediante l'aggiunta degli input del decoratore specializzato 'arrow keys' con quello da decorare.
	
	\paragraph{Vantaggi e Svantaggi:}
	Il pattern Factory facilita la creazione di diverse configurazioni di comandi, migliorando la modularità e la scalabilità del codice. Tuttavia, può aumentare la complessità del sistema con molte classi e richiede una progettazione attenta.
	Mentre il pattern Decorator consente di estendere dinamicamente le configurazioni di comandi aggiungendo input specializzati, offrendo flessibilità e personalizzazione. Tuttavia, può rendere il codice più complesso e difficile da gestire a causa della proliferazione di decoratori.
	
	\subsubsection{Costruzione di World}
	
	\paragraph{Problema:} Per poter implementare correttamente un contenitore delle entità di gioco è necessario costruirlo in modo sicuro e privo di comportamenti indesiderati come l'aggiunta di un'entità in posti non idonei (specialmente dopo aver cominciato il game loop).
	
	\paragraph{Soluzione:} Il pattern \textit{Builder} soddisfa a pieno tale richieste in quanto permette la costruzione del mondo delle entità una sola volta, in fase di inizializzazione per esempio, inoltre, oltre a rendere il codice maggiormente leggibile, facilita la possibiltà di modellare un      \texttt{World} secondo una precisa configurazione di oggetti.
	
	\paragraph{Vantaggi e Svantaggi:}
	Il pattern \textit{Builder} offre il vantaggio di garantire una costruzione sicura e coerente del contenitore delle entità di gioco, evitando l'aggiunta non autorizzata di entità e migliorando la leggibilità del codice. Tuttavia, può introdurre complessità aggiuntiva nel processo di costruzione e potrebbe risultare eccessivo per configurazioni semplici, comportando un aumento del tempo di sviluppo e delle risorse necessarie.
	
	
	\subsubsection{Coordinamento della View}
	
	\paragraph{Problema:} Non è stata semplice la gestione della view, in quanto molte classi utilzzate dipendono dal framework utilizzato e non è possibile gestirle tutte in maniera dislocata, specie per il cambio della vista, la quale richede l'accesso a diverse istanze legate all'applicazione.
	
	\paragraph{Soluzione:} Una soluzione ad occhio e croce sarebbe quella di implementare la gestione della view in un unico metodo, o attverso la costruzione in un' elaborata gerarchia di classi in modo da avere a disposizione tutte le istanze legate all'applicazione pronte per essere accedute. Tale soluzione venne subito scartata in quanto, oltre ad essere troppo corposa, molti metodi differenti dovevano richiedere
	l'accesso alla vista (magari per cambiarla) e non potevano raggiungerla a causa di una mancata centralizzazione di essa. Il pattern \textit{Singleton} risponde esattamente ai mancati adempimenti della precedente soluzione, in quanto ogni classe ha l'accesso alla classe centralizzata {ViewManager} e tali operazioni restano sicure in quanto essa viene inizilizzata durante la creazione dell'applicazione e quindi prima di ogni eventuale modifca del gioco.
	
	\paragraph{Vantaggi e Svantaggi:} Il pattern \textit{Singleton} offre una gestione centralizzata e sicura della vista, permettendo a tutte le classi di accedere a una singola istanza di ViewManager. Questo approccio garantisce coerenza e semplifica la modifica della vista, evitando problemi di sincronizzazione e accesso non coordinato. Tuttavia, può introdurre un accoppiamento rigido tra le classi e la vista, riducendo la flessibilità del sistema e rendendolo più difficile da testare. Inoltre, se non gestito correttamente, il Singleton può diventare un punto di congestione nel codice, con tutte le classi che dipendono dalla stessa istanza.
	
	
	
	
	\subsection{Junkai Ji}
	
	\subsubsection{Effect}
	\paragraph{Problema:} Con una struttura molto frammentata, comprendere come e a chi applicare gli effetti può diventare complesso. Ogni effetto deve sapere sia chi è il destinatario dell’effetto (target) che chi lo applica (self). Questa complessità aumenta quando gli effetti possono essere applicati non solo tra il giocatore e un oggetto, ma tra qualsiasi coppia di oggetti di gioco. La gestione di tali effetti richiede una chiara comprensione delle relazioni e delle priorità per garantire che gli effetti siano applicati e rimossi correttamente.
	\paragraph{Soluzione Proposta:} L’interfaccia Effect è progettata per gestire esplicitamente i dettagli dell’applicazione degli effetti. Il metodo apply consente di specificare sia l’oggetto destinatario dell’effetto (target) che l’oggetto che applica l’effetto (self), permettendo una gestione chiara e flessibile delle interazioni. Questo approccio è sufficientemente generico da supportare effetti tra qualsiasi coppia di oggetti di gioco, non limitandosi solo al giocatore e agli oggetti con cui interagisce.
	\paragraph{Vantaggi e Svantaggi:}
	Il design proposto consente una gestione chiara e versatile degli effetti, facilitando l’applicazione di effetti tra qualsiasi coppia di oggetti di gioco. La struttura generica e la capacità di gestire effetti asincroni tramite CompletableFuture migliorano l’efficienza e la flessibilità del sistema. Tuttavia, la generica natura degli effetti richiede una gestione accurata per evitare confusione e garantire che gli effetti siano applicati e rimossi correttamente.
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=\textwidth]{img/effect.png}
		\caption{Schema UML di Effect}
		\label{img:effect}
	\end{figure}
	
	
	\subsubsection{Trigger}
	\paragraph{Problema:} In un gioco, è comune che gli effetti debbano essere attivati non solo in risposta a collisioni tra il giocatore e gli ostacoli, ma anche in base ad altre condizioni o eventi nel gioco. Questo richiede un meccanismo che possa attivare effetti anche in assenza di collisioni dirette, modificando dinamicamente la mappa del gioco.
	\paragraph{Soluzione Proposta:} L’interfaccia Trigger estende MutableObject e introduce metodi specifici per gestire l’attivazione di azioni o eventi associati a una collezione di ostacoli. 
	\paragraph{Vantaggi e Svantaggi:}
	L’uso dei trigger consente di attivare effetti senza dipendere esclusivamente dalle collisioni. Questo approccio arricchisce il gameplay e la complessità del gioco. Tuttavia, uno svantaggio significativo è che i trigger devono essere configurati e associati correttamente prima del loro utilizzo
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=\textwidth]{img/trigger.png}
		\caption{Schema UML di Trigger}
		\label{img:trigger}
	\end{figure}
	
	\subsubsection{EffectHandler}
	\paragraph{Problema:} La gestione degli effetti applicati durante le collisioni tra il giocatore e gli oggetti di gioco può diventare complessa, specialmente quando si tratta di avere sequenze di effetti di lunghezza variabile e diversi livelli. È fondamentale garantire che gli effetti vengano applicati correttamente e che le risorse siano gestite in modo efficiente.
	\paragraph{Soluzione Proposta:} La classe \texttt{EffectHandlerImpl} gestisce l’applicazione e la gestione degli effetti nel gioco. Utilizza \texttt{TypeEffectsManager} e \texttt{ObjectEffectsManager} per separare e gestire gli effetti basati sui tipi di collisione e sugli oggetti specifici. Gli effetti possono essere sia generali (per tipo di collisione) sia specifici (per oggetti), e la classe è in grado di applicare e resettare questi effetti in modo coerente. Inoltre, è capace di ricreare gli effetti se necessario, utilizzando la riflessione per verificare e invocare il metodo \texttt{recreate} degli effetti.
	\paragraph{Vantaggi e Svantaggi:}
	Il principale vantaggio è che gli effetti sono completamente estratti dagli oggetti di gioco, eliminando la necessità di una relazione diretta tra effetti e oggetti. Questo approccio, centralizzato attraverso l’\texttt{EffectHandlerImpl}, migliora la struttura del codice e facilita la gestione degli effetti a livello globale. Tuttavia, l’uso di questa classe può introdurre problemi di performance a causa della ricreazione e eliminazione degli effetti.
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=\textwidth]{img/effecthandler.png}
		\caption{Schema UML di EffectHandler}
		\label{img:effecthandler}
	\end{figure}
	
	\subsubsection{CollisionManager}
	\paragraph{Problema:} La gestione delle collisioni comporta una sequenza di passaggi complessi e ordinati. È necessario gestire non solo l’applicazione degli effetti, ma anche considerare le priorità tra le varie operazioni, come l’attivazione degli eventi di trigger prima dell’applicazione degli effetti e le operazioni di pulizia successivamente. 
	\paragraph{Soluzione Proposta:}  CollisionManager e CollisionObserver utilizzano un design modulare per affrontare questa complessità. CollisionManager si occupa della rilevazione delle collisioni, mentre CollisionObserver gestisce l’applicazione e il reset degli effetti. Utilizzando BiConsumerWithAndThen, è possibile creare una lista ordinata di BiConsumer, ciascuno rappresentante un passaggio specifico nel processo di gestione delle collisioni. Questo approccio permette di definire chiaramente le priorità tra le operazioni: prima vengono attivati gli eventi di trigger, poi applicati gli effetti, e infine eseguite le operazioni di pulizia e reset. La possibilità di concatenare questi BiConsumer in modo chiaro e modulare consente un codice pulito e facilmente manutenibile.
	\paragraph{Vantaggi e Svantaggi:} Il design modulare e l’uso di BiConsumerWithAndThen permettono una gestione ordinata e flessibile delle collisioni e degli effetti, rispettando le priorità tra le operazioni. Questo approccio migliora la modularità e la manutenzione del codice. Tuttavia, l’introduzione di passaggi aggiuntivi e la gestione delle priorità possono aumentare la complessità e richiedere un’attenta pianificazione per evitare conflitti tra le operazioni.
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=\textwidth]{img/collisionmanager.png}
		\caption{Schema UML di Collision Manager}
		\label{img:collisionmanager}
	\end{figure}
	
	
	\subsubsection{EventManager}
	\paragraph{Problema:} La comunicazione tra classi diverse può diventare complessa, specialmente in un’applicazione con molteplici componenti e moduli. Passare istanze tra le classi può creare un forte accoppiamento e rendere il codice meno manutenibile. È necessario un meccanismo che permetta la comunicazione tra classi senza creare dipendenze dirette tra di esse.
	\paragraph{Soluzione Proposta:} Il EventManager utilizza un design centralizzato per gestire gli eventi e le azioni correlate. Implementa il pattern Singleton per assicurare che solo una istanza gestisca tutti gli eventi, migliorando la coerenza e facilitando l’accesso globale. Gli eventi e le loro azioni sono gestiti tramite una mappa (eventMap) che associa i tipi di eventi (eventType) a gestori di eventi (BiConsumerWithAndThen). Questo approccio permette di:
	\begin{itemize}
		\item Isolare la Comunicazione: Le classi possono comunicare tra loro attraverso eventi senza riferimenti diretti.
		\item Flessibilità: È possibile passare qualsiasi tipo di oggetto come parametro agli eventi, rendendo il EventManager altamente generico.
		\item Gestione degli Eventi: Gli eventi vengono pubblicati e gestiti centralmente, semplificando la gestione e la manutenzione del codice.
	\end{itemize}
	\paragraph{Vantaggi e Svantaggi:}
	Il EventManager offre un design flessibile e centralizzato per la comunicazione tra classi, migliorando la manutenibilità e riducendo il forte accoppiamento. Tuttavia, questa flessibilità può essere pericolosa, poiché chi pubblica un evento deve garantire che i sottoscrittori abbiano metodi compatibili con i parametri dell’evento pubblicato. È essenziale che chi utilizza il EventManager sia consapevole delle specifiche degli eventi e dei parametri per evitare errori di runtime e garantire che le azioni siano eseguite correttamente.
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=\textwidth]{img/eventmanager.png}
		\caption{Schema UML di Event Manager}
		\label{img:eventmanager}
	\end{figure}
	
	\section{Conclusioni}
	
	Il design di \textit{Paradox Platformer} è stato progettato per garantire estensibilità, chiarezza e modularità. L'uso dei pattern di design come \textit{Strategy}, \textit{Factory} e \textit{Observer} ha permesso di creare un'architettura modulare e flessibile, facilitando l'aggiunta di nuove funzionalità e la manutenzione del codice. Tuttavia, è importante monitorare la complessità introdotta dai pattern e bilanciare la flessibilità con la semplicità per evitare problemi di gestione e performance.
	
	
	\chapter{Sviluppo}
	\section{Testing automatizzato}
	
	l testing automatico delle classi sviluppate è stato realizzato utilizzando \textbf{JUnit}. Ogni membro del gruppo è stato incaricato di creare test per le proprie classi.
	
	\subsection{Junkai Ji}
	\begin{itemize}
		\item \textbf{TriggerTest}: verifica che il trigger attivi correttamente gli effetti associati e testa che il trigger possa attivare gli effetti degli ostacoli associati come previsto.
		
		\item \textbf{EffectTest}: controlla che gli effetti vengano applicati correttamente al giocatore.
		
		\item \textbf{EffectHandlerTest}: testa la gestione degli effetti da parte dell’EffectHandler, verificando che gli effetti vengano aggiunti, rimossi e applicati correttamente.
		
		\item \textbf{CollisionTest}: verifica che il CollisionManager rilevi e gestisca correttamente le collisioni tra il giocatore e gli ostacoli.
		
		\item \textbf{EventManagerTest}: testa che l’EventManager gestisca correttamente l’iscrizione e la notifica degli eventi.
	\end{itemize}
	
	\subsection{Keegan Carlo Falcao}
	
	\begin{itemize}
		\item \textbf{InputControllerTest}: gestione di molteplici input (simulati) e la costruzione di un game loop semplice. Tale test è esente dalla vista.
		
		\item \textbf{SimpleInventoryTest}: testa la correttezza del contenuto dell'inventario, come ad esempio la raccolta della stessa moneta.
		
		\item \textbf{GameModelTest}: testa la correttezza di inizilizzare il modello di gioco e la eventuale gestione dei casi specifici.
		
		\item \textbf{WorldBuilderTest}: controllo dell'effettiva costruzione del mondo.
		
		\item \textbf{WorldTest}: verifica la corretta creazione di un mondo presentando diverse problematiche per casi specifici
	\end{itemize}
	
	\section{Note di sviluppo}
	
	
	\subsection{Junkai Ji}
	
	\subsubsection{Utilizzo di \texttt{Generic}}
	Utilizzata in vari punti.
	Un esempio è 
	\url{https://github.com/OlivieriMichele/OOP23-paradox-platformer/blob/main/src/main/java/com/project/paradoxplatformer/controller/event/EventManager.java}
	
	\subsubsection{Utilizzo di \texttt{Stream} e lambda expressions}
	Utilizzata in vari punti.
	Un esempio è 
	\url{https://github.com/OlivieriMichele/OOP23-paradox-platformer/blob/main/src/main/java/com/project/paradoxplatformer/model/effect/managers/TypeEffectsManager.java}
	
	\subsubsection{Utilizzo di \texttt{Reflection}}
	Un esempio è 
	\url{https://github.com/OlivieriMichele/OOP23-paradox-platformer/blob/main/src/main/java/com/project/paradoxplatformer/model/effect/impl/EffectHandlerImpl.java}
	
	\subsubsection{Utilizzo di \texttt{Custom Biconsumer}}
	Utilizzata in vari punti.
	Un esempio è 
	\url{https://github.com/OlivieriMichele/OOP23-paradox-platformer/blob/main/src/main/java/com/project/paradoxplatformer/utils/collision/CollisionObserver.java}
	
	\subsection{Keegan Carlo Falcao}
	
	\subsubsection{Utilizzo di \texttt{Generic}}
	Utilizzata in vari punti.
	Un esempio è
	\url{https://github.com/OlivieriMichele/OOP23-paradox-platformer/blob/aa3a3632b5f52afbd8fd600a9a28f06283fda177/src/main/java/com/project/paradoxplatformer/controller/input/InputController.java#L21}
	
	\subsubsection{Utilizzo di \texttt{Stream} e lambda expressions e \texttt{Collectors}}
	Utilizzata in vari punti.
	Un esempio è
	\url{https://github.com/OlivieriMichele/OOP23-paradox-platformer/blob/c38556bb255d05a7f1e0d3def90e5e85b7abedbf/src/main/java/com/project/paradoxplatformer/view/GameViewImpl.java#L85}
	
	\url{https://github.com/OlivieriMichele/OOP23-paradox-platformer/blob/9840a583905bdab26639a7a675e05b6c16bd4a6c/src/main/java/com/project/paradoxplatformer/model/player/Inventory.java#L49}
	
	\subsubsection{Utilizzo di \texttt{Reflection}}
	Un esempio è
	\url{https://github.com/OlivieriMichele/OOP23-paradox-platformer/blob/aa3a3632b5f52afbd8fd600a9a28f06283fda177/src/main/java/com/project/paradoxplatformer/model/mappings/model/ModelMappingFactoryImpl.java#L80}
	
	\subsubsection{Utilizzo di \texttt{Jackson Deserializaton}}
	Un esempio è
	\url{https://github.com/OlivieriMichele/OOP23-paradox-platformer/blob/aa3a3632b5f52afbd8fd600a9a28f06283fda177/src/main/java/com/project/paradoxplatformer/controller/deserialization/DeserializerFactoryImpl.java#L24}
	
	\subsubsection{Utilizzo di \texttt{Pair} di guava}
	Un esempio è
	\url{https://github.com/OlivieriMichele/OOP23-paradox-platformer/blob/aa3a3632b5f52afbd8fd600a9a28f06283fda177/src/main/java/com/project/paradoxplatformer/utils/geometries/physic/api/Physics.java#L44}
	
	\subsubsection{Utilizzo di \texttt{Function}}
	Un esempio è
	\url{https://github.com/OlivieriMichele/OOP23-paradox-platformer/blob/aa3a3632b5f52afbd8fd600a9a28f06283fda177/src/main/java/com/project/paradoxplatformer/view/legacy/ViewAdapterFactory.java#L82}
	
	\subsubsection{Utilizzo di \texttt{Optional}}
	Un esempio è
	\url{https://github.com/OlivieriMichele/OOP23-paradox-platformer/blob/aa3a3632b5f52afbd8fd600a9a28f06283fda177/src/main/java/com/project/paradoxplatformer/controller/input/api/InputType.java#L95}
	
	\subsubsection{Utilizzo di \texttt{@FunctionalInterface}}
	Un esempio è
	\url{https://github.com/OlivieriMichele/OOP23-paradox-platformer/blob/aa3a3632b5f52afbd8fd600a9a28f06283fda177/src/main/java/com/project/paradoxplatformer/utils/geometries/interpolations/Interpolator.java#L12}
	
	
	\chapter{Commenti finali}
	
	\section{Autovalutazione e lavori futuri}
	
	\subsection{Junkai Ji}
	Nel corso di questo progetto, sono abbastanza soddisfatto del lavoro che ho svolto, nonostante le sfide e le limitazioni che abbiamo affrontato. La nostra squadra ha dovuto gestire diversi problemi e vincoli di tempo, il che ha impedito una collaborazione coordinata tra i membri. Tuttavia, sono contento di essere riuscito a portare avanti le nostre parti singolarmente per poi combinare il nostro lavoro per ottenere un applicativo finale funzionante. La gestione del tempo è stata una sfida, e alcuni aspetti del lavoro sono stati affrettati a causa delle scadenze. Questo ha influito sulla qualità di alcune sezioni e ha limitato il tempo dedicato ai test e alla struttura del progetto.
	\subsection{Michele Olivieri}
	Nel complesso, condivido pienamente le riflessioni dei miei collegi su questo progetto. Nonostante le difficoltà e le limitazioni incontrate, come la gestione del tempo e la mancanza di una collaborazione più coordinata, sono soddisfatto del risultato finale. Mi dispiace, tuttavia, non essere riuscito a raggiungere alcuni degli obiettivi che mi ero prefissato, specialmente per quanto riguarda la struttura del mio lavoro. Guardando indietro, penso che avrei potuto fare meglio in alcune aree. C'è stata forse una certa mancanza di coesione nella divisione dei compiti e nella definizione di una struttura comune, ma devo riconoscere l'alta competenza dei miei colleghi, che ci ha permesso di trovare una soluzione e combinare con successo i nostri contributi per ottenere un applicativo funzionante.
	\subsection{Keegan Carlo Falcao}
	Il progetto ha presentato sfide significative su molteplici fronti. Sul piano personale, questa esperienza di lavoro di gruppo mi ha reso profondamente consapevole dell'inestimabile valore della collaborazione e dell'impegno collettivo, elementi essenziali per condurre a buon fine un progetto accuratamente concepito e pianificato. Le difficoltà incontrate, mai affrontate prima nella mia carriera accademica, si sono rivelate tutt'altro che agevoli, ma mi considero fortunato per aver avuto l'opportunità di misurarmi con tali ostacoli e di superarli con successo.
	
	Dal punto di vista progettuale, l'attività è stata portata avanti con dedizione, persino in seguito alla separazione di un membro del team, evento che ha reso la distribuzione dei compiti più complessa e nebulosa.
	
	Ritengo, tuttavia, che avremmo dovuto dedicare maggiore attenzione a un'analisi più profonda della progettazione e a una strategia di comunicazione più efficace, poiché sono emerse evidenti carenze in queste aree. Una cura più rigorosa avrebbe certamente contribuito a un esito progettuale più fluido e armonioso.
	
	\appendix
	\chapter{Guida utente}
	
	Questa guida illustra come utilizzare l’applicazione \textit{Paradox Platformer} e fornisce istruzioni chiare per iniziare a giocare. Anche se il gioco è intuitivo, è utile spiegare alcune funzionalità fondamentali per i nuovi utenti.
	
	\section{Avvio del gioco}
	
	\begin{enumerate}
		\item Quando si avvia il gioco, verrà visualizzato un menu principale contenente l’elenco dei livelli disponibili.
		\item Il giocatore può selezionare uno dei 4 livelli cliccando sul nome del livello desiderato. Il livello selezionato verrà caricato immediatamente, e il giocatore potrà iniziare a giocare.
	\end{enumerate}
	
	\section{Controlli di gioco}
	
	Per muovere il personaggio nel mondo di \textit{Paradox Platformer}, il giocatore può utilizzare i seguenti tasti:
	
	\begin{itemize}
		\item \textbf{W} o \textbf{Freccia Su}: Salto
		\item \textbf{A} o \textbf{Freccia Sinistra}: Movimento verso sinistra
		\item \textbf{D} o \textbf{Freccia Destra}: Movimento verso destra
	\end{itemize}
	
	\bibliographystyle{alpha}
	\bibliography{13-template}
	
\end{document}